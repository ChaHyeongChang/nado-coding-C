
//p219 a4 [8]필기 (2차원 배열과 포인터의 관계1)

//2차원 배열은 포인터 타입이 열에 따라서 달라진다!!
//포인터를 움직일 때 !행단위!로 움직임

#include <stdio.h>

int main(void){

    //int p; --> 정수를 저장
    //int *p; --> p는 int형의 주소를 저장하는 포인터 4byte의 주소를 저장 (p의 크기는 항상 8byte : 포인터 이므로)
    //int *p[2] --> 포인터 배열

    //int (*p)[2] --> p는 int형의 데이터를 2개씩 점프하는 포인터 (8byte씩 점프)

    int a[3][2]; //열에 따라서 몇byte가 증가하는지 결정됨!
    //a(배열의 이름)은 포인터 (시작 주소를 가리킴)
    //+1 할때마다 8byte 씩 증가(4byte 짜리 메모리를 2개씩 점프하므로)

    int (*p)[2]; //( )를 안쓰면 포인터 배열과 구분할 수 없음!! 따라서 2차원 배열의 포인터 타입을 선언할때는 ( )사용
                //[ ]안의 값은 int형의 변수를 몇개씩 점프하는지 결정


    int b[4][3]; //열에 따라서 몇byte가 증가하는지 결정됨!
    //b(배열의 이름)은 포인터 (시작 주소를 가리킴)
    //+1 할때마다 12byte 씩 증가(4byte 자리 메모리를 3개씩 점프하므로)

    int (*p2)[3]; // b는 시작 주소를 가리키므로 p2 = b
                //( )를 안쓰면 포인터 배열과 구분할 수 없음!! 따라서 2차원 배열의 포인터 타입을 선언할때는 ( )사용
                //[ ]안의 값은 int형의 변수를 몇개씩 점프하는지 결정

    
    printf("%d\n", sizeof(*p+1)); // 8 : sizeof(*p) == sizeof(int[2]) int[2]의 크기는 2 x sizeof(int) = 2 x 4 = 8
    printf("%d\n", sizeof(a)); // 24 : 배열의 총 원소 수 3 x 2 = 6, sizeof(int) = 4, 6 x 4 = 24byte
    printf("%d\n\n", sizeof(p)); // 8 : 포인터의 크기는 항상 8byte 이므로(몇  byte 점프하는것과 크기는 별개임)

    printf("%d\n", sizeof(*p2)); // 12 : sizeof(*p2) == sizeof(int[3]) int[3]의 크기는 3 x sizeof(int) = 3 x 4 = 12
    printf("%d\n", sizeof(b)); // 48 : 따라서 4 x 12 = 48byte
                                // 배열의 총 원소 수 4 x 3 = 12
                                // sizeof(int) == 4
    printf("%d\n", sizeof(p2)); // 8 : 포인터의 크기는 항상 8byte 이므로(몇  byte 점프하는것과 크기는 별개임)
    //변수 p2는 int (*)[3]타입의 포인터, 즉 p2는 #int [3]를 가리키는 포인터# 이므로 sizeof(p2)는 일반적인 포인터의 크기와 동일!
    
    //#int [3]를 가리키는 포인터에 대한 설명#
    //b자체는 int[4][3]
    //b는 "4개의 int[3] 배열"이 모여있는 2차원 배열
    //b의 각 행(b[0], b[1], ...)은 각각 int [3]타입


    return 0;
}
/*
ex) double d[4][3]; double (*p)[3];
    char c[1000][1024]; char (*p)[1024];
    double arr[100][3]; double (*p)[3];

    //자료형과 열이 같다면 행에 상관없이 포인터 타입은 일치(ex : (*p)[3] )

*/
