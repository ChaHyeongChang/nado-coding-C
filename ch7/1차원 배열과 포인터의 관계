//🔥배열의 이름은 포인터🔥, 배열의 이름만 쓰게되면 배열의 시작 주소를 나타내는 포인터
//배열이 포인터라는 것이 아님!! --> 배열의 이름이 포인터!
//배열에 인덱스를 붙이지 않고 배열의 이름 a만 딱 쓴다고 하면 &a[0](a 0번째의 주소)와 같음
//배열의 이름은 배열의 첫 번째 주소를 가리키는 포인터

//🔥배열은 결국은 포인터를 1씩 증가하면서 만들어지는 자료구조🔥
//✅배열에서 인덱스나 *(역참조)를 사용하면 원소값을 나타낼 수 있고 원소값을 나타내기위해서 인덱스나 *(역참조)가 필요한 이유는 배열의 이름이 포인터이기 때문임!✅
//따라서서 배열의 이름이 포인터이기 때문에 배열을 함수로 전달하는 방법을 배워야함
/*
#include <stdio.h>

int main(void){
    int a[5] = {1,2,3,4,5};
    int *p; //int형의 주소를 포인터로 선언
    p = a; //배열의 이름도 포인터이기 때문에 포인터의 배열의 이름(배열의 시작주소)를 가리키는 것이 가능
    //p는 a배열의 시작 주소를 가리키게됨
    
    return 0;
}
*/

//***포인터 연산***
/*
    포인터는 가리키는 역할을 하는데 포인터 변수의 중간 주소값을 가지는것은 아무 의미가 없기 때문에 가리키는 포인터의 크기만큼 증가하거나 감소함!!
    포인터가 int형이면 4byte 증가, char형이면 1byte 증가, double형이면 8byte 증가 
    -->포인터는 연산할 때 가리키는 데이터의 크기(int, char, double ...)만큼 증가하거나 감소함

    ex) int *p;를 100번지라고 하면 p+1 ? --> 104번지
        char *p;를 100번지라고 하면 p+1 ? --> 101번지
        double *p;를 100번지라고 하면 p+1 ? --> 108번지

    따라서
    *(a + 2) => 3, *(a + 4) => 5
    *(p + 1) => 2, *(p + 4) => 5

    *(a + 2) == a[2]
    *(a + 4) == a[4]

    배열이라는 자료구조는 포인터로 만들어짐
    --> a라는 포인터 하나로 1씩 증가하면서 만들어진 자료구조 : 일차원 배열
    ----> 배열의 인덱스가 0부터 시작하는 이유는 배열의 포인터에서 주소 증가를 하지 않았기 때문!!
    ==> a[0]은 (a + 0)이 가리키는 메모리 a[0] == *(a + 0), a[1]은 a + 1이 가리키는 메모리 a[1] == *(a + 1) .....

    지금까지는 역참조 할 때 *만 가능한줄 알았는데 사실 인덱스 연산자가 하는 일이 배열의 주소를 가리키는 값이었음!!!! --> a[1]을 쓰나 *(a + 1)을 쓰나 완벽하게 같은 의미
    --> 배열 : a라는 포인터 하나로 포인터를 1씩 증가하면서 만들어진 연속적인 자료 공간
    --> 따라서 인덱스와 *(역참조)의 다른점은 없음
*/ 

#include <stdio.h>

int main(void){
    int a = 5;
    int *p = &a; //p는 a의 주소를 가리킴

    //두 식의 의미가 같음!!
    *p = 10;
    p[0] = 10;
    //인덱스 : 포인터가 가리키는 메모리인데 주소 증가를 몇 번 하느냐!! --> 배열이라도 인덱스를 나타내지 않으면 주소값을 가리키는 것임!
                                                                        //ex) a[1]은 2, (a + 1)은 &a[1] (의 첫번째 주소값), *(a + 1)은 2
    return 0;
}
